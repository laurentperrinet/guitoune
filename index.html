<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Guitoune: the mobile‚ÄëFriendly Guitar Tuner</title>
<style>
  html,body{
    margin:0; height:100%; overflow:hidden;
    background:#111; color:#eee;
    font-family:Arial,Helvetica,sans-serif;
  }
  .stringRow{
    position:relative;
    width:100%;
    height:calc(100vh/6);
    overflow:hidden;
  }
  canvas{
    display:block;
    width:100%; height:100%;
    background:#222;               /* water‚Äëfall background */
  }
  .noteLabel{
    position:absolute;
    right:0.5rem;
    top:50%; transform:translateY(-50%);
    font-size:2.4rem; font-weight:bold;
    color:#fff; text-shadow:0 0 6px rgba(0,0,0,0.9);
    pointer-events:none; z-index:2;
  }
  .stringRow::after{
    content:"";
    position:absolute;
    left:0; right:0; bottom:0; height:2px;
    background:#555; display:none;
  }
  .stringRow:not(:last-child)::after{display:block;}

  /* ---- loudness dot (lower‚Äëleft) ----
     Transparent background, red fill with 80‚ÄØ% opacity, perfect disc */
  #volDot{
    position:absolute;
    left:1rem;
    bottom:1rem;
    width:300px;               /* large enough to show a big dot */
    height:300px;
    pointer-events:none;
    background:transparent;    /* make the canvas itself transparent */
  }
</style>
</head>
<body>

<div id="tunerContainer"></div>
<canvas id="volDot"></canvas>               <!-- loudness indicator -->

<script>
/*=====================================================================
   1Ô∏è‚É£ GLOBAL DSP CONFIG ‚Äì every field now has a short description.
   =====================================================================*/
const DSP_CONFIG = {
  /* Cents shown on each side of the centre. 100 ‚Üí ¬±1 semitone. */
  DISPLAY_CENTS   : 100,

  /* Number of frequency columns (horizontal resolution). */
  COLS            : 35,

  /* Number of time rows kept (vertical resolution). */
  ROWS            : 30,

  /* How often we run the heavy pitch analysis (ms). */
  UPDATE_INTERVAL : 100,

  /* Band‚Äëpass limits (Hz). */
  HP_CUT          : 30,
  LP_CUT          : 1500,          // still high enough for B3/E4

  /* Q‚Äëfactor for the two band‚Äëpass filters. */
  BAND_Q          : 0.707,

  /* FFT size ‚Äì larger = finer frequency bins, more CPU. */
  FFT_SIZE        : 16384,

  /* Minimum correlation to accept a pitch. Lower = less ‚Äúholes‚Äù. */
  CORRELATION_MIN : 0.05,

  /* Weight of the newest correlation when smoothing (0‚ÄØ‚Üí‚ÄØ1). */
  CORRELATION_SMOOTH_ALPHA : 0.2,   // smoother colour evolution

  /* Dim factor for strings that are not the active one. */
  OTHER_DIM_FACTOR : 0.3,

  /* How many raw pitch detections we keep for the median filter. */
  PITCH_HISTORY_LENGTH : 20,       // you asked for this

  /* Weight of the old correlation when no pitch is detected. */
  SMOOTH_ALPHA_OLD : 0.8
};
/*=====================================================================
   2Ô∏è‚É£ GUITAR NOTES (standard tuning)
   =====================================================================*/
const STRINGS = [
  {name:'E2', freq: 82.41},
  {name:'A2', freq:110.00},
  {name:'D3', freq:146.83},
  {name:'G3', freq:196.00},
  {name:'B3', freq:246.94},
  {name:'E4', freq:329.63}
];

/*=====================================================================
   3Ô∏è‚É£ UI ‚Äì one canvas + overlay label per string
   =====================================================================*/
const container = document.getElementById('tunerContainer');
const canvases = [];                     // keep references to each canvas
STRINGS.forEach(s => {
  const row = document.createElement('div');
  row.className = 'stringRow';
  row.innerHTML = `
    <canvas></canvas>
    <div class="noteLabel">${s.name}</div>
  `;
  container.appendChild(row);
  canvases.push(row.querySelector('canvas'));
});

/*=====================================================================
   4Ô∏è‚É£ AUDIO PIPELINE
       mic ‚Üí high‚Äëpass ‚Üí low‚Äëpass ‚Üí high‚Äëshelf (pre‚Äëemphasis) ‚Üí analyser
   =====================================================================*/
let audioCtx, analyser, source, hp, lp, preEmphasis;
let lastUpdate = performance.now();     // timestamp of the last analysis
let rafId = null;

/* histories[string][row] ‚Üí {col, hue, light, alpha} or null */
const histories = STRINGS.map(()=>Array(DSP_CONFIG.ROWS).fill(null));

/* Exponential smoothing of the correlation value (for colour/brightness). */
let smoothedCorrelation = null;

/* Short‚Äëterm pitch history ‚Äì used for a robust median filter. */
let pitchHistory = [];

/* Latest RMS value ‚Äì drives the loud‚Äëness dot. */
let currentRMS = 0;

/*=====================================================================
   5Ô∏è‚É£ START ‚Äì request microphone, build graph, start animation loop
   =====================================================================*/
async function startTuner(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    /* ---------- high‚Äëpass (30‚ÄØHz) ---------- */
    hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = DSP_CONFIG.HP_CUT;
    hp.Q.value = DSP_CONFIG.BAND_Q;

    /* ---------- low‚Äëpass (1800‚ÄØHz) ---------- */
    lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = DSP_CONFIG.LP_CUT;
    lp.Q.value = DSP_CONFIG.BAND_Q;

    /* ---------- high‚Äëshelf ‚Äúpre‚Äëemphasis‚Äù
        This filter makes the spectrum rise roughly linearly with frequency,
        i.e. higher‚Äëpitched notes (B3,‚ÄØE4) get a little extra boost. ---------- */
    preEmphasis = audioCtx.createBiquadFilter();
    preEmphasis.type = 'highshelf';
    preEmphasis.frequency.value = 1000;   // start boosting around 1‚ÄØkHz
    preEmphasis.gain.value = 6;           // +6‚ÄØdB; feel free to adjust

    /* ---------- analyser (FFT) ---------- */
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = DSP_CONFIG.FFT_SIZE;
    analyser.smoothingTimeConstant = 0;   // we perform our own smoothing

    /* ---------- connect the graph ---------- */
    source = audioCtx.createMediaStreamSource(stream);
    source.connect(hp);
    hp.connect(lp);
    lp.connect(preEmphasis);
    preEmphasis.connect(analyser);

    if (audioCtx.state === 'suspended') await audioCtx.resume();
    resizeCanvases();                    // pixel‚Äëperfect canvas sizing
    rafId = requestAnimationFrame(mainLoop);
  }catch(e){
    alert('Erreur d‚Äôacc√®s au micro‚ÄØ:\n'+e);
  }
}

/*=====================================================================
   6Ô∏è‚É£ Resize canvases ‚Äì make the drawing buffer match the displayed size
   =====================================================================*/
function resizeCanvases(){
  const rows = document.querySelectorAll('.stringRow');
  rows.forEach(row => {
    const canvas = row.querySelector('canvas');
    canvas.width  = row.clientWidth;
    canvas.height = row.clientHeight;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  });
}
window.addEventListener('resize', resizeCanvases);

/*=====================================================================
   7Ô∏è‚É£ AUTOCORRELATION ‚Äì core pitch‚Äëdetection algorithm
       Returns {freq, correlation, rms} or null (if no clear pitch).
   =====================================================================*/
function autoCorrelate(buf, sampleRate){
  const SIZE = buf.length;
  const MAX  = Math.floor(SIZE/2);

  /* ---- RMS (used later for the loudness dot) ---- */
  let rms = 0;
  for(let i=0;i<SIZE;i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms/SIZE);
  if(rms < 0.01) return null;               // signal too quiet ‚Üí ignore

  /* ---- simple autocorrelation ‚Äì find the lag with highest similarity ---- */
  let bestOffset = -1, bestCorr = 0, lastCorr = 1;
  for(let offset=0; offset<MAX; offset++){
    let corr = 0;
    if(offset + MAX > buf.length) break;
    for(let i=0;i<MAX;i++) corr += Math.abs(buf[i] - buf[i+offset]);
    corr = 1 - (corr / MAX);                 // normalise to 0‚Äë1
    if(corr > 0.9 && corr > lastCorr){
      if(corr > bestCorr){ bestCorr = corr; bestOffset = offset; }
    }
    lastCorr = corr;
  }
  if(bestOffset === -1) return null;        // no clear peak

  /* ---- parabolic interpolation ‚Äì sub‚Äësample precision ---- */
  const left   = bestOffset > 0 ? 1 - Math.abs(corrAt(buf,bestOffset-1)) : 0;
  const centre = 1 - Math.abs(corrAt(buf,bestOffset));
  const right  = (bestOffset+1 < MAX) ? 1 - Math.abs(corrAt(buf,bestOffset+1)) : 0;
  const denom = (left - 2*centre + right);
  let delta = 0;
  if(denom !== 0) delta = 0.5 * (left - right) / denom;
  const refined = bestOffset + delta;

  /* ---- convert lag ‚Üí frequency (Hz) ---- */
  const pitch = sampleRate / refined;
  return {freq:pitch, correlation:bestCorr, rms};
}
function corrAt(buf, offset){
  const MAX = Math.floor(buf.length/2);
  let corr = 0;
  for(let i=0;i<MAX;i++) corr += Math.abs(buf[i] - buf[i+offset]);
  return corr / MAX;
}

/*=====================================================================
   8Ô∏è‚É£ HELPERS ‚Äì colour, lightness, opacity, coordinate conversion
   =====================================================================*/
function hueFromCents(c){
  const max = DSP_CONFIG.DISPLAY_CENTS;
  const lim = Math.max(-max, Math.min(max, c));
  // -max ‚Üí 0¬∞ (red) | 0 ‚Üí 120¬∞ (green) | +max ‚Üí 240¬∞ (blue)
  return lim < 0 ? 120 * (1 + lim / max) : 120 + 120 * (lim / max);
}
function lightnessFromCorr(c){ return 10 + 80 * c; }   // 10‚ÄØ% ‚Üí 90‚ÄØ%
function alphaFromCorr(c){ return c; }               // opacity = correlation

function centsToCol(cents){
  const step = (2*DSP_CONFIG.DISPLAY_CENTS) / (DSP_CONFIG.COLS-1);
  let col = Math.round((cents + DSP_CONFIG.DISPLAY_CENTS) / step);
  if(col < 0) col = 0;
  if(col >= DSP_CONFIG.COLS) col = DSP_CONFIG.COLS-1;
  return col;
}
function centsToX(cents, canvas){
  const half = canvas.width/2;
  const pxPerCent = half / DSP_CONFIG.DISPLAY_CENTS;
  let x = Math.round(half + cents * pxPerCent);
  if(x < 0) x = 0;
  if(x >= canvas.width) x = canvas.width-1;
  return x;
}

/*=====================================================================
   9Ô∏è‚É£ MEDIAN utility ‚Äì robust pitch from recent history
   =====================================================================*/
function median(arr){
  const sorted = arr.slice().sort((a,b)=>a-b);
  const mid = Math.floor(sorted.length/2);
  return sorted.length % 2 ? sorted[mid] : (sorted[mid-1]+sorted[mid])/2;
}

/*=====================================================================
   üîü DRAW THE LOUDNESS DOT (transparent canvas, 80‚ÄØ% opaque red disc)
   =====================================================================*/
function drawVolumeDot(){
  const dot = document.getElementById('volDot');
  const ctx = dot.getContext('2d');
  const w = dot.width, h = dot.height;

  ctx.clearRect(0,0,w,h);                    // erase previous frame

  // Map RMS (0 ‚Ä¶ 0.30) ‚Üí radius (0 ‚Ä¶ 140‚ÄØpx)
  const maxRMS   = 0.30;
  const maxRadius = 140;
  const radius = Math.min(maxRadius,
                         Math.max(0,
                           (currentRMS - 0) / (maxRMS - 0) * maxRadius));

  // Perfect disc, filled with 80‚ÄØ% opacity (globalAlpha = 0.8)
  ctx.fillStyle = '#ff4444';
  ctx.globalAlpha = 0.8;                     // 80‚ÄØ% opacity
  ctx.beginPath();
  ctx.arc(w/2, h/2, radius, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = 1;                       // restore default alpha
}

/*=====================================================================
   1Ô∏è‚É£1Ô∏è‚É£ MAIN LOOP ‚Äì runs every animation frame.
       * Every `UPDATE_INTERVAL`‚ÄØms we do the heavy pitch analysis.
       * RMS ‚Üí loudness dot.
       * Autocorrelation ‚Üí raw pitch.
       * Median filter ‚Üí robust pitch.
       * Exponential smoothing of correlation (for colour/brightness).
       * Determine which string is ‚Äúactive‚Äù (closest in cents).
       * Push a new row into the waterfall history for each string.
       * Finally draw everything.
   =====================================================================*/
let lastActiveIdx = -1;          // which string is currently the ‚Äúactive‚Äù one
function mainLoop(timestamp){
  // --------------------------------------------------------------
  // 1Ô∏è‚É£ Run the heavy pitch analysis only every UPDATE_INTERVAL ms.
  // --------------------------------------------------------------
  if (timestamp - lastUpdate >= DSP_CONFIG.UPDATE_INTERVAL){
    const buf = new Float32Array(analyser.fftSize);
    analyser.getFloatTimeDomainData(buf);   // get the time‚Äëdomain signal

    /* ---- 1Ô∏è‚É£ Compute RMS (used for the loudness dot) ---- */
    let sum = 0;
    for(let i=0;i<buf.length;i++) sum += buf[i]*buf[i];
    const rms = Math.sqrt(sum / buf.length);
    currentRMS = rms;                       // drive the dot

    /* ---- 2Ô∏è‚É£ Pitch detection via autocorrelation ---- */
    const rawInfo = autoCorrelate(buf, audioCtx.sampleRate); // {freq, correlation, rms} or null

    /* ---- 3Ô∏è‚É£ Store raw detections for the median filter ---- */
    pitchHistory.push(rawInfo);
    if (pitchHistory.length > DSP_CONFIG.PITCH_HISTORY_LENGTH) pitchHistory.shift();

    /* ---- 4Ô∏è‚É£ Median filter ‚Äì gives a more stable pitch value ---- */
    const valid = pitchHistory.filter(v=>v!==null);
    let robustInfo = null;
    if(valid.length){
      const freqs = valid.map(v=>v.freq);
      const cors  = valid.map(v=>v.correlation);
      const medianFreq = median(freqs);
      const medianCorr = median(cors);
      if(medianCorr >= DSP_CONFIG.CORRELATION_MIN){
        robustInfo = {freq:medianFreq, correlation:medianCorr};
      }
    }

    /* --------------------------------------------------------------
       5Ô∏è‚É£ Exponential smoothing of the correlation (used for colour
          intensity). If no pitch is detected we let the old value
          decay with SMOOTH_ALPHA_OLD.
       -------------------------------------------------------------- */
    if(robustInfo){
      if(smoothedCorrelation===null) smoothedCorrelation = robustInfo.correlation;
      else{
        const newAlpha = DSP_CONFIG.CORRELATION_SMOOTH_ALPHA;
        const oldAlpha = 1 - newAlpha;
        smoothedCorrelation = oldAlpha*smoothedCorrelation + newAlpha*robustInfo.correlation;
      }
    }else{
      if(smoothedCorrelation!==null) smoothedCorrelation *= DSP_CONFIG.SMOOTH_ALPHA_OLD;
    }

    /* --------------------------------------------------------------
       6Ô∏è‚É£ Determine which string is the ‚Äúactive‚Äù one.
          For every string we compute the distance in **cents**:
          ```
          cents = 1200 * log2( measuredFreq / referenceFreq )
          ```
          *1200* is the number of cents in one octave
          (100‚ÄØcents per semitone √ó 12 semitones = 1200).  
          `log2(freq / ref)` gives the number of octaves difference,
          multiplying by 1200 converts that to cents.
       -------------------------------------------------------------- */
    let activeIdx = -1;
    let minAbs = Infinity;
    const centsArray = new Array(STRINGS.length).fill(null);
    if(robustInfo){
      const {freq} = robustInfo;
      STRINGS.forEach((s,i)=>{
        const cents = 1200 * Math.log2(freq / s.freq);   // 1200 = cents per octave
        centsArray[i] = cents;
        const abs = Math.abs(cents);
        if(abs < minAbs){
          minAbs = abs;
          activeIdx = i;
        }
      });
      // If the deviation is larger than the displayed window we discard it.
      if(minAbs > DSP_CONFIG.DISPLAY_CENTS) activeIdx = -1;
    }
    lastActiveIdx = activeIdx;

    /* --------------------------------------------------------------
       7Ô∏è‚É£ Push a new row into the waterfall history for every string.
       -------------------------------------------------------------- */
    STRINGS.forEach((s, idx) => {
      let entry = null;
      if(robustInfo){
        const cents = centsArray[idx];
        const col   = centsToCol(cents);
        const hue   = hueFromCents(cents);
        const baseLight = lightnessFromCorr(smoothedCorrelation);
        const baseAlpha = alphaFromCorr(smoothedCorrelation);
        const light = (activeIdx===idx) ? baseLight
                                        : baseLight * DSP_CONFIG.OTHER_DIM_FACTOR;
        const alpha = (activeIdx===idx) ? baseAlpha
                                        : baseAlpha * DSP_CONFIG.OTHER_DIM_FACTOR;
        entry = {col, hue, light, alpha};
      }
      histories[idx].push(entry);
      if(histories[idx].length > DSP_CONFIG.ROWS) histories[idx].shift();
    });

    lastUpdate = timestamp;
  }

  // --------------------------------------------------------------
  // 8Ô∏è‚É£ Draw the waterfall visualisation (unchanged apart from config values)
  // --------------------------------------------------------------
  drawAllCanvases();

  // --------------------------------------------------------------
  // 9Ô∏è‚É£ Draw the loudness dot (transparent canvas, 80‚ÄØ% opaque disc)
  // --------------------------------------------------------------
  drawVolumeDot();

  rafId = requestAnimationFrame(mainLoop);
}

/*=====================================================================
   1Ô∏è‚É£3Ô∏è‚É£ DRAWING ROUTINE ‚Äì waterfall + note label
   =====================================================================*/
function drawAllCanvases(){
  STRINGS.forEach((s, idx) => {
    const canvas = canvases[idx];
    const ctx = canvas.getContext('2d');
    const colW = canvas.width / DSP_CONFIG.COLS;
    const rowH = canvas.height / DSP_CONFIG.ROWS;

    /* ---- 1Ô∏è‚É£ background ---- */
    ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    /* ---- 2Ô∏è‚É£ guide lines (center and ¬±10 cents) ---- */
    const centreX = canvas.width/2;
    const leftX   = centsToX(-10, canvas);
    const rightX  = centsToX(10,  canvas);
    ctx.strokeStyle = '#30d158'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(centreX,0); ctx.lineTo(centreX,canvas.height);
    ctx.stroke();
    ctx.strokeStyle = '#ff8800'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(leftX,0); ctx.lineTo(leftX,canvas.height);
    ctx.moveTo(rightX,0); ctx.lineTo(rightX,canvas.height);
    ctx.stroke();

    /* ---- 3Ô∏è‚É£ draw the stored history rows (oldest at the top) ---- */
    histories[idx].forEach((entry, rowIdx) => {
      if(!entry) return;
      ctx.fillStyle = `hsl(${entry.hue},100%,${entry.light}%)`;
      ctx.globalAlpha = entry.alpha;
      const y = rowIdx * rowH;
      ctx.fillRect(entry.col * colW, y, colW, rowH);
    });
    ctx.globalAlpha = 1;   // reset alpha for the next drawing step

    /* ---- 4Ô∏è‚É£ big note name for the active string (if any) ---- */
    if(lastActiveIdx === idx && histories[idx].length){
      const latest = histories[idx][histories[idx].length-1];
      if(latest){
        ctx.fillStyle = `hsl(${latest.hue},100%,${latest.light}%)`;
        ctx.globalAlpha = latest.alpha;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 3.6rem Arial,Helvetica,sans-serif';
        ctx.fillText(s.name, canvas.width/2, canvas.height/2);
        ctx.globalAlpha = 1;
      }
    }
  });
}

/*=====================================================================
   1Ô∏è‚É£4Ô∏è‚É£ AUTO‚ÄëSTART on page load
   =====================================================================*/
window.addEventListener('load', startTuner);
</script>
</body>
</html>