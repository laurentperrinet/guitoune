<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Guitoune: the mobile‑Friendly 6‑String Guitar Tuner</title>
<style>
  html,body{
    margin:0; height:100%; overflow:hidden;
    background:#111; color:#eee;
    font-family:Arial,Helvetica,sans-serif;
  }
  .stringRow{
    position:relative;                /* for label & separator */
    width:100%;
    height:calc(100vh/6);
    overflow:hidden;
  }
  canvas{
    display:block;
    width:100%; height:100%;
    background:#222;
  }
  .noteLabel{
    position:absolute;
    right:0.5rem;
    top:50%; transform:translateY(-50%);
    font-size:2.4rem; font-weight:bold;
    color:#fff; text-shadow:0 0 6px rgba(0,0,0,0.9);
    pointer-events:none; z-index:2;
  }
  .stringRow::after{
    content:""; position:absolute;
    left:0; right:0; bottom:0; height:2px;
    background:#555; display:none;
  }
  .stringRow:not(:last-child)::after{display:block;}
</style>
</head>
<body>

<div id="tunerContainer"></div>

<script>
/* ---------------------------------------------------------
   SETTINGS
   --------------------------------------------------------- */
const STRINGS = [
  {name:'E2', freq: 82.41},
  {name:'A2', freq:110.00},
  {name:'D3', freq:146.83},
  {name:'G3', freq:196.00},
  {name:'B3', freq:246.94},
  {name:'E4', freq:329.63}
];

const DISPLAY_CENTS = 50;          // ±50 cents shown left↔right
const COLS = 41;                  // columns (log‑frequency)
const ROWS = 10;                  // rows (time)
const UPDATE_INTERVAL = 100;     // UI refresh every 100 ms (10 Hz)

const HP_CUT = 70;                // band‑pass low‑cut
const LP_CUT = 450;               // band‑pass high‑cut
const BAND_Q = 0.707;             // Butterworth‑type Q

const OTHER_DIM_FACTOR = 0.2;      // how much to dim the “non‑active” strings

/* ---------------------------------------------------------
   UI – one canvas + overlay label per string
   --------------------------------------------------------- */
const container = document.getElementById('tunerContainer');
const canvases = [];                // keep canvas refs
STRINGS.forEach(s => {
  const row = document.createElement('div');
  row.className = 'stringRow';
  row.innerHTML = `
    <canvas></canvas>
    <div class="noteLabel">${s.name}</div>
  `;
  container.appendChild(row);
  canvases.push(row.querySelector('canvas'));
});

/* ---------------------------------------------------------
   AUDIO GRAPH (band‑pass + analyser)
   --------------------------------------------------------- */
let audioCtx, analyser, source, hp, lp, intervalId;
const rowIdx = new Array(STRINGS.length).fill(0); // scrolling row per string

async function startTuner(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // ----- band‑pass (70 Hz – 450 Hz) -----
    hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = HP_CUT;
    hp.Q.value = BAND_Q;

    lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = LP_CUT;
    lp.Q.value = BAND_Q;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 8192;                 // wider window → more robust pitch
    analyser.smoothingTimeConstant = 0;      // we handle fading ourselves

    source = audioCtx.createMediaStreamSource(stream);
    source.connect(hp);
    hp.connect(lp);
    lp.connect(analyser);

    if (audioCtx.state === 'suspended') await audioCtx.resume();

    resizeCanvases();

    // UI updates at a human‑playable rate (10 Hz)
    intervalId = setInterval(update, UPDATE_INTERVAL);
  }catch(e){
    alert('Microphone access error:\n'+e);
  }
}

/* ---------------------------------------------------------
   Resize canvases to match device pixel dimensions
   --------------------------------------------------------- */
function resizeCanvases(){
  const rows = document.querySelectorAll('.stringRow');
  rows.forEach(row => {
    const canvas = row.querySelector('canvas');
    canvas.width  = row.clientWidth;
    canvas.height = row.clientHeight;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  });
}
window.addEventListener('resize', resizeCanvases);

/* ---------------------------------------------------------
   AUTOCORRELATION (wide FFT, sub‑sample interpolation)
   --------------------------------------------------------- */
function autoCorrelate(buf, sampleRate){
  const SIZE = buf.length;
  const MAX  = Math.floor(SIZE/2);

  // ---- RMS (silence test) ----
  let rms = 0;
  for(let i=0;i<SIZE;i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms/SIZE);
  if(rms < 0.01) return null;                 // too quiet

  // ---- simple autocorrelation ----
  let bestOffset = -1, bestCorr = 0, lastCorr = 1;
  for(let offset=0; offset<MAX; offset++){
    let corr = 0;
    if(offset + MAX > buf.length) break;
    for(let i=0;i<MAX;i++) corr += Math.abs(buf[i] - buf[i+offset]);
    corr = 1 - (corr / MAX);                  // 0‑1
    if(corr > 0.9 && corr > lastCorr){
      if(corr > bestCorr){ bestCorr = corr; bestOffset = offset; }
    }
    lastCorr = corr;
  }
  if(bestOffset === -1) return null;

  // ---- parabolic interpolation (sub‑sample) ----
  const left   = bestOffset > 0 ? 1 - Math.abs(corrAt(buf,bestOffset-1)) : 0;
  const centre = 1 - Math.abs(corrAt(buf,bestOffset));
  const right  = (bestOffset+1 < MAX) ? 1 - Math.abs(corrAt(buf,bestOffset+1)) : 0;
  const denom = (left - 2*centre + right);
  let delta = 0;
  if(denom !== 0) delta = 0.5 * (left - right) / denom;
  const refined = bestOffset + delta;

  const pitch = sampleRate / refined;
  return {freq:pitch, correlation:bestCorr};
}
function corrAt(buf, offset){
  const MAX = Math.floor(buf.length/2);
  let corr = 0;
  for(let i=0;i<MAX;i++) corr += Math.abs(buf[i] - buf[i+offset]);
  return corr / MAX;
}

/* ---------------------------------------------------------
   Helper functions – colour ↔ cents ↔ pixel
   --------------------------------------------------------- */
function hueFromCents(c){
  const max = DISPLAY_CENTS;
  const lim = Math.max(-max, Math.min(max, c));
  return lim < 0 ? 120 * (1 + lim / max) : 120 + 120 * (lim / max);
}
function lightnessFromCorr(c){ return 30 + 55 * c; }   // 0‑1 → 30‑85 %
function centsToCol(cents){
  const step = (2*DISPLAY_CENTS) / (COLS-1);
  let col = Math.round((cents + DISPLAY_CENTS) / step);
  if(col < 0) col = 0;
  if(col >= COLS) col = COLS-1;
  return col;
}
function centsToX(cents, canvas){
  const half = canvas.width/2;
  const pxPerCent = half / DISPLAY_CENTS;
  let x = Math.round(half + cents * pxPerCent);
  if(x < 0) x = 0;
  if(x >= canvas.width) x = canvas.width-1;
  return x;
}

/* ---------------------------------------------------------
   MAIN UPDATE – runs every UPDATE_INTERVAL (100 ms)
   --------------------------------------------------------- */
function update(){
  const buf = new Float32Array(analyser.fftSize);
  analyser.getFloatTimeDomainData(buf);
  const pitchInfo = autoCorrelate(buf, audioCtx.sampleRate); // {freq, correlation} or null

  // ---- Determine which string is the “active” one (closest cents) ----
  let activeIdx = -1;
  let smallestAbsCents = Infinity;
  const centsArray = new Array(STRINGS.length).fill(null); // store per‑string cents

  if(pitchInfo){
    const {freq} = pitchInfo;
    STRINGS.forEach((s, i) => {
      const cents = 1200 * Math.log2(freq / s.freq);
      centsArray[i] = cents;
      const abs = Math.abs(cents);
      if(abs < smallestAbsCents){
        smallestAbsCents = abs;
        activeIdx = i;
      }
    });
    // If the best match is more than DISPLAY_CENTS away, treat as “no active string”
    if(smallestAbsCents > DISPLAY_CENTS) activeIdx = -1;
  }

  // ---- Draw each canvas -------------------------------------------------
  STRINGS.forEach((s, idx) => {
    const canvas = canvases[idx];
    const ctx = canvas.getContext('2d');

    const colW = canvas.width / COLS;
    const rowH = canvas.height / ROWS;

    // 1️⃣ fade previous content
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // 2️⃣ vertical guide lines (always)
    const centreX = canvas.width/2;
    const leftX   = centsToX(-10, canvas);
    const rightX  = centsToX(10, canvas);

    ctx.strokeStyle = '#30d158'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(centreX,0); ctx.lineTo(centreX,canvas.height);
    ctx.stroke();

    ctx.strokeStyle = '#ff8800'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(leftX,0); ctx.lineTo(leftX,canvas.height);
    ctx.moveTo(rightX,0); ctx.lineTo(rightX,canvas.height);
    ctx.stroke();

    // 3️⃣ draw a coloured block if we have a pitch
    if(pitchInfo){
      const cents = centsArray[idx];
      const hue   = hueFromCents(cents);
      // base lightness from correlation
      let light   = lightnessFromCorr(pitchInfo.correlation);
      // dim non‑active strings
      if(activeIdx !== -1 && idx !== activeIdx){
        light *= OTHER_DIM_FACTOR;          // make them much darker
      }
      ctx.fillStyle = `hsl(${hue},100%,${light}%)`;

      const col = centsToCol(cents);
      const row = rowIdx[idx];
      const y   = canvas.height - (row + 1) * rowH; // bottom‑most row = 0
      ctx.fillRect(col * colW, y, colW, rowH);
    }

    // 4️⃣ advance the scrolling row
    rowIdx[idx] = (rowIdx[idx] + 1) % ROWS;
  });
}

/* ---------------------------------------------------------
   AUTO‑START on page load (asks for mic permission)
   --------------------------------------------------------- */
window.addEventListener('load', startTuner);
</script>
</body>
</html>