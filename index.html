<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Guitoune: the mobile‑Friendly 6‑String Guitar Tuner</title>
<style>
  html,body{
    margin:0; height:100%; overflow:hidden;
    background:#111; color:#eee;
    font-family:Arial,Helvetica,sans-serif;
  }
  /* One row per string – each row occupies 1/6 of the viewport height */
  .stringRow{
    display:flex;
    align-items:center;
    width:100%;
    height:calc(100vh/6);
  }
  canvas{
    flex:1 1 auto;               /* fill the remaining width */
    display:block;                /* remove inline‑canvas whitespace */
    background:#222;            /* fallback colour while we draw */
  }
  .noteLabel{
    flex:0 0 3.5rem;            /* fixed width for the note text */
    font-size:2.2rem;
    font-weight:bold;
    text-align:center;
    color:#fff;
  }
</style>
</head>
<body>

<div id="tunerContainer"></div>

<script>
/* ---------------------------------------------------------
   SETTINGS
   --------------------------------------------------------- */
const STRINGS = [
  {name:'E2', freq: 82.41},
  {name:'A2', freq:110.00},
  {name:'D3', freq:146.83},
  {name:'G3', freq:196.00},
  {name:'B3', freq:246.94},
  {name:'E4', freq:329.63}
];

const DISPLAY_CENTS = 50;          // ±50 cents visible left↔right
const COLS = 21;                   // columns (log‑frequency)
const ROWS = 10;                   // rows (time)

// helpers for colour conversion
function hueFromCents(c){
  const max = DISPLAY_CENTS;
  const cLim = Math.max(-max, Math.min(max, c));
  // -max → 0° (red) | 0 → 120° (green) | +max → 240° (blue)
  return cLim < 0
    ? 120 * (1 + cLim / max)          // 120 → 0
    : 120 + 120 * (cLim / max);      // 120 → 240
}
function lightnessFromCorr(c){
  // correlation (0‑1) → lightness 30 %‑85 %
  return 30 + 55 * c;
}
function centsToCol(cents){
  const step = (2 * DISPLAY_CENTS) / (COLS - 1);   // size of one column in cents
  let col = Math.round((cents + DISPLAY_CENTS) / step);
  if (col < 0) col = 0;
  if (col >= COLS) col = COLS - 1;
  return col;
}

/* ---------------------------------------------------------
   BUILD UI – one canvas + note label per string
   --------------------------------------------------------- */
const container = document.getElementById('tunerContainer');
const canvases = [];                     // keep a reference to each canvas
STRINGS.forEach(s => {
  const row = document.createElement('div');
  row.className = 'stringRow';
  row.innerHTML = `
    <canvas></canvas>
    <div class="noteLabel">${s.name}</div>
  `;
  container.appendChild(row);
  const canvas = row.querySelector('canvas');
  canvases.push(canvas);
});

/* ---------------------------------------------------------
   AUDIO + PITCH DETECTION
   --------------------------------------------------------- */
let audioCtx, analyser, source, highPass, lowPass, rafId;
const rowIndices = new Array(STRINGS.length).fill(0);   // current time‑row per string

async function startTuner(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    /* ----- band‑pass filter (70 Hz – 450 Hz) ----- */
    highPass = audioCtx.createBiquadFilter();
    highPass.type = 'highpass';
    highPass.frequency.value = 70;
    highPass.Q.value = 0.707;

    lowPass = audioCtx.createBiquadFilter();
    lowPass.type = 'lowpass';
    lowPass.frequency.value = 450;
    lowPass.Q.value = 0.707;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 4096;               // larger window → more stable pitch

    source = audioCtx.createMediaStreamSource(stream);
    source.connect(highPass);
    highPass.connect(lowPass);
    lowPass.connect(analyser);

    if (audioCtx.state === 'suspended') await audioCtx.resume();

    resizeCanvases();                      // set the drawing buffer size
    rafId = requestAnimationFrame(update);
  }catch(e){
    alert('Microphone access error:\n' + e);
  }
}

/* ---------------------------------------------------------
   Resize canvases to match their on‑screen size (pixel‑perfect)
   --------------------------------------------------------- */
function resizeCanvases(){
  const rows = document.querySelectorAll('.stringRow');
  rows.forEach(row => {
    const canvas = row.querySelector('canvas');
    canvas.width  = row.clientWidth;    // drawing buffer size
    canvas.height = row.clientHeight;
    // clear with dark background
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  });
}
window.addEventListener('resize', resizeCanvases);

/* ---------------------------------------------------------
   Autocorrelation pitch detector (returns {freq, correlation})
   --------------------------------------------------------- */
function detectPitch(buf, sampleRate){
  const SIZE = buf.length;
  const MAX = Math.floor(SIZE/2);
  // RMS – discard silence
  let rms = 0;
  for (let i=0;i<SIZE;i++) rms += buf[i]*buf[i];
  rms = Math.sqrt(rms/SIZE);
  if (rms < 0.01) return null;    // too quiet

  let bestOffset = -1, bestCorr = 0, lastCorr = 1;
  for (let offset=0; offset<MAX; offset++) {
    let corr = 0;
    if (offset + MAX > buf.length) break;
    for (let i=0; i<MAX; i++) corr += Math.abs(buf[i] - buf[i+offset]);
    corr = 1 - (corr / MAX);      // normalised correlation 0‑1
    if (corr > 0.9 && corr > lastCorr) {
      if (corr > bestCorr) { bestCorr = corr; bestOffset = offset; }
    }
    lastCorr = corr;
  }
  if (bestOffset === -1) return null;
  const freq = sampleRate / bestOffset;
  return {freq, correlation:bestCorr};
}

/* ---------------------------------------------------------
   MAIN UPDATE LOOP – draw fading coloured dots
   --------------------------------------------------------- */
function update(){
  const buf = new Float32Array(analyser.fftSize);
  analyser.getFloatTimeDomainData(buf);
  const pitchInfo = detectPitch(buf, audioCtx.sampleRate);

  // We will always advance the time‑row (so the visual grid scrolls)
  STRINGS.forEach((s, idx) => {
    const canvas = canvases[idx];
    const ctx = canvas.getContext('2d');

    const colW = canvas.width  / COLS;
    const rowH = canvas.height / ROWS;

    // 1️⃣ Fade the whole canvas a little (older dots become darker)
    ctx.fillStyle = 'rgba(0,0,0,0.15)';   // alpha controls fade speed
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // 2️⃣ If we have a pitch, draw a new dot in the current row
    if (pitchInfo){
      const {freq, correlation} = pitchInfo;
      const cents = 1200 * Math.log2(freq / s.freq);
      const col   = centsToCol(cents);
      const hue   = hueFromCents(cents);
      const light = lightnessFromCorr(correlation);
      ctx.fillStyle = `hsl(${hue},100%,${light}%)`;
      const row = rowIndices[idx];
      // draw the block at the *bottom‑most* row for row=0, then move up
      const y = canvas.height - (row + 1) * rowH;
      ctx.fillRect(col * colW, y, colW, rowH);
    }

    // 3️⃣ Advance the row for the next frame (wrap after ROWS)
    rowIndices[idx] = (rowIndices[idx] + 1) % ROWS;
  });

  rafId = requestAnimationFrame(update);
}

/* ---------------------------------------------------------
   AUTO‑START on page load
   --------------------------------------------------------- */
window.addEventListener('load', () => {
  startTuner();          // asks for microphone permission immediately
});
</script>
</body>
</html>