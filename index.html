<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Guitoune: Guitar Tuner</title>
<style>
  html,body{
    margin:0; height:100%; overflow:hidden;
    background:#111; color:#eee;
    font-family:Arial,Helvetica,sans-serif;
  }
  .stringRow{
    position:relative;
    width:100%;
    height:calc(100vh/6);
    overflow:hidden;
  }
  canvas{
    display:block;
    width:100%; height:100%;
    background:#222;
  }
  .noteLabel{
    position:absolute;
    right:0.5rem;
    top:50%; transform:translateY(-50%);
    font-size:2.4rem; font-weight:bold;
    color:#fff;
    text-shadow:0 0 6px rgba(0,0,0,0.9);
    pointer-events:none; z-index:2;
  }
  .stringRow::after{
    content:"";
    position:absolute;
    left:0; right:0; bottom:0; height:2px;
    background:#555; display:none;
  }
  .stringRow:not(:last-child)::after{display:block;}
</style>
</head>
<body>
<div id="tunerContainer"></div>
<script>
/*============== CONFIG =================*/
const DSP_CONFIG = {
  DISPLAY_CENTS   : 100,
  COLS            : 35,
  ROWS            : 30,
  UPDATE_INTERVAL : 100,
  FFT_SIZE        : 8192,
  HP_CUT          : 70,
  LP_CUT          : 600,
  BAND_Q          : 0.707,
  RMS_THRESHOLD   : 0.01,
  CORRELATION_MIN : 0.5,
  MIN_FREQ        : 60,
  MAX_FREQ        : 400
};

/*============== GUITAR STRINGS =================*/
const STRINGS = [
  {name:'E2', freq: 82.41},
  {name:'A2', freq:110.00},
  {name:'D3', freq:146.83},
  {name:'G3', freq:196.00},
  {name:'B3', freq:246.94},
  {name:'E4', freq:329.63}
];

/*============== UI SETUP =================*/
const container = document.getElementById('tunerContainer');
const canvases = [];
const noteLabels = [];

STRINGS.forEach(s => {
  const row = document.createElement('div');
  row.className = 'stringRow';
  row.innerHTML = `<canvas></canvas><div class="noteLabel">${s.name}</div>`;
  container.appendChild(row);
  canvases.push(row.querySelector('canvas'));
  noteLabels.push(row.querySelector('.noteLabel'));
});

/*============== AUDIO =================*/
let audioCtx, analyser, source, hp, lp;
let lastUpdate = 0;
let histories = STRINGS.map(() => Array(DSP_CONFIG.ROWS).fill(null));
let lastActiveIdx = -1;

/*============== START =================*/
async function startTuner(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    hp = audioCtx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = DSP_CONFIG.HP_CUT;
    hp.Q.value = DSP_CONFIG.BAND_Q;

    lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = DSP_CONFIG.LP_CUT;
    lp.Q.value = DSP_CONFIG.BAND_Q;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = DSP_CONFIG.FFT_SIZE;
    analyser.smoothingTimeConstant = 0;

    source = audioCtx.createMediaStreamSource(stream);
    source.connect(hp);
    hp.connect(lp);
    lp.connect(analyser);

    if (audioCtx.state === 'suspended') await audioCtx.resume();

    resizeCanvases();
    requestAnimationFrame(mainLoop);
  }catch(e){
    alert('Micro error: ' + e);
  }
}

function resizeCanvases(){
  canvases.forEach(canvas => {
    const row = canvas.parentElement;
    canvas.width = row.clientWidth;
    canvas.height = row.clientHeight;
  });
}
window.addEventListener('resize', resizeCanvases);

/*============== AUTOCORRELATION (SIMPLIFIED) =================*/
function autoCorrelate(buf, sampleRate) {
  const SIZE = buf.length;
  
  // RMS check
  let sumSq = 0;
  for (let i = 0; i < SIZE; i++) sumSq += buf[i] * buf[i];
  const rms = Math.sqrt(sumSq / SIZE);
  if (rms < DSP_CONFIG.RMS_THRESHOLD) return null;
  
  // Search range for guitar frequencies
  const minLag = Math.floor(sampleRate / DSP_CONFIG.MAX_FREQ);
  const maxLag = Math.floor(sampleRate / DSP_CONFIG.MIN_FREQ);
  
  let bestLag = -1;
  let bestCorr = -1;
  
  // Standard autocorrelation
  for (let lag = minLag; lag <= maxLag; lag++) {
    let num = 0;   // numerator
    let den1 = 0;  // denominator part 1
    let den2 = 0;  // denominator part 2
    
    for (let i = 0; i < SIZE - lag; i++) {
      num += buf[i] * buf[i + lag];
      den1 += buf[i] * buf[i];
      den2 += buf[i + lag] * buf[i + lag];
    }
    
    const denom = Math.sqrt(den1 * den2);
    if (denom === 0) continue;
    
    const corr = num / denom;
    if (corr > bestCorr) {
      bestCorr = corr;
      bestLag = lag;
    }
  }
  
  if (bestLag === -1 || bestCorr < DSP_CONFIG.CORRELATION_MIN) return null;
  
  // Simple parabolic interpolation
  if (bestLag > minLag && bestLag < maxLag) {
    const y1 = autocorrAt(buf, bestLag - 1);
    const y2 = bestCorr;
    const y3 = autocorrAt(buf, bestLag + 1);
    
    const d = (y1 - 2*y2 + y3);
    if (d !== 0) {
      const delta = (y1 - y3) / (2 * d);
      if (Math.abs(delta) < 1) bestLag += delta;
    }
  }
  
  return {
    freq: sampleRate / bestLag,
    correlation: bestCorr,
    rms: rms
  };
}

function autocorrAt(buf, lag) {
  let num = 0, den1 = 0, den2 = 0;
  for (let i = 0; i < buf.length - lag; i++) {
    num += buf[i] * buf[i + lag];
    den1 += buf[i] * buf[i];
    den2 += buf[i + lag] * buf[i + lag];
  }
  const denom = Math.sqrt(den1 * den2);
  return denom === 0 ? 0 : num / denom;
}

/*============== HELPERS =================*/
function hueFromCents(c){
  const max = DSP_CONFIG.DISPLAY_CENTS;
  const lim = Math.max(-max, Math.min(max, c));
  return lim < 0 ? 120 * (1 + lim/max) : 120 + 120 * (lim/max);
}

function centsToCol(cents){
  const step = (2*DSP_CONFIG.DISPLAY_CENTS) / (DSP_CONFIG.COLS-1);
  let col = Math.round((cents + DSP_CONFIG.DISPLAY_CENTS) / step);
  return Math.max(0, Math.min(DSP_CONFIG.COLS-1, col));
}

function centsToX(cents, canvas){
  const half = canvas.width/2;
  const pxPerCent = half / DSP_CONFIG.DISPLAY_CENTS;
  return Math.max(0, Math.min(canvas.width-1, Math.round(half + cents*pxPerCent)));
}

function noteNameFromFreq(freq){
  const noteNames = ['C','C♯','D','D♯','E','F','F♯','G','G♯','A','A♯','B'];
  const midi = Math.round(69 + 12 * Math.log2(freq/440));
  const noteIndex = (midi % 12 + 12) % 12;
  const octave = Math.floor(midi / 12) - 1;
  return noteNames[noteIndex] + octave;
}

/*============== MAIN LOOP =================*/
function mainLoop(timestamp){
  if (timestamp - lastUpdate >= DSP_CONFIG.UPDATE_INTERVAL){
    const buf = new Float32Array(analyser.fftSize);
    analyser.getFloatTimeDomainData(buf);
    
    const detection = autoCorrelate(buf, audioCtx.sampleRate);
    
    // Find closest string
    let activeIdx = -1;
    let minCents = Infinity;
    const centsArray = [];
    
    if (detection) {
      STRINGS.forEach((s, i) => {
        const cents = 1200 * Math.log2(detection.freq / s.freq);
        centsArray[i] = cents;
        const absCents = Math.abs(cents);
        if (absCents < minCents) {
          minCents = absCents;
          activeIdx = i;
        }
      });
      
      if (minCents > DSP_CONFIG.DISPLAY_CENTS) activeIdx = -1;
    }
    
    lastActiveIdx = activeIdx;
    
    // Update labels
    STRINGS.forEach((s, idx) => {
      if (idx === activeIdx && detection) {
        noteLabels[idx].textContent = noteNameFromFreq(detection.freq);
        noteLabels[idx].style.color = '#0f0';
      } else {
        noteLabels[idx].textContent = s.name;
        noteLabels[idx].style.color = '#fff';
      }
    });
    
    // Update history
    STRINGS.forEach((s, idx) => {
      let entry = null;
      if (detection) {
        const cents = centsArray[idx];
        const col = centsToCol(cents);
        const hue = hueFromCents(cents);
        const corr = detection.correlation;
        const light = 10 + 80 * corr;
        const alpha = activeIdx === idx ? corr : corr * 0.5;
        entry = {col, hue, light, alpha};
      }
      histories[idx].push(entry);
      if (histories[idx].length > DSP_CONFIG.ROWS) histories[idx].shift();
    });
    
    lastUpdate = timestamp;
  }
  
  draw();
  requestAnimationFrame(mainLoop);
}

/*============== DRAW =================*/
function draw(){
  STRINGS.forEach((s, idx) => {
    const canvas = canvases[idx];
    if (!canvas || canvas.width === 0) return;
    
    const ctx = canvas.getContext('2d');
    const colW = canvas.width / DSP_CONFIG.COLS;
    const rowH = canvas.height / DSP_CONFIG.ROWS;
    
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Guide lines
    const centreX = canvas.width/2;
    const leftX = centsToX(-10, canvas);
    const rightX = centsToX(10, canvas);
    
    ctx.strokeStyle = '#30d158';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centreX, 0);
    ctx.lineTo(centreX, canvas.height);
    ctx.stroke();
    
    ctx.strokeStyle = '#ff8800';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(leftX, 0);
    ctx.lineTo(leftX, canvas.height);
    ctx.moveTo(rightX, 0);
    ctx.lineTo(rightX, canvas.height);
    ctx.stroke();
    
    // Waterfall
    histories[idx].forEach((entry, rowIdx) => {
      if (!entry) return;
      ctx.fillStyle = `hsl(${entry.hue},100%,${entry.light}%)`;
      ctx.globalAlpha = entry.alpha;
      ctx.fillRect(entry.col * colW, rowIdx * rowH, colW, rowH);
    });
    ctx.globalAlpha = 1;
  });
}

/*============== START =================*/
window.addEventListener('load', startTuner);
</script>
</body>
</html>